<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- metadata -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- tab title -->
    <title>Final Report | Interactive Fluid Simulation</title>

    <!-- load icon -->
    <link rel="shortcut icon" href="../favicon.ico" type="image/x-icon" />

    <!-- load fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap"
      rel="stylesheet"
    />

    <!-- load website styles -->
    <link rel="stylesheet" href="../global.css" />
    <link rel="stylesheet" href="../article.css" />
    <link rel="stylesheet" href="../footer.css" />
  </head>
  <body>
    <main>
      <article>
        <header>
          <h1>Interactive Fluid Simulation</h1>
          <h3>Final Report</h3>
          <p class="gray">
            Team: Ann Basil, Ben Bliss, David Hernandez, Jinkang Fang
          </p>
          <p>
            Webpage:
            <a
              href="https://jinkang-0.github.io/water-that-flows-real-good/final/"
              >jinkang-0.github.io/water-that-flows-real-good/final/</a
            >
          </p>
        </header>
        <section>
          <h2>Abstract</h2>
          <p>
            This project explores an application of fluid simulations in an
            interactive setting. We chose to create a demo inspired by a game
            called Where's My Water, where the goal is to guide pockets of water
            by carving a path in the terrain and having gravity lead our water
            particles to the target destination.
          </p>
        </section>
        <section>
          <h2>Technical Approach</h2>
          <h3>Fluid Simultion</h3>
          <p>
            For fluid simulation, we used a method called PIC/FLIP, which is a
            hybrid of both particle-based (Lagrangian) and grid-based (Eulerian)
            approaches. The PIC/FLIP method uses particle positions and
            velocities to approximate the fluid volume, but uses a grid to solve
            for fluid incompressibility, transfering velocities in between
            mediums in each step. As a result, we obtain both the smooth
            fluid-like motion from the Eulerian approach and the benefits of
            finer details from particle positions.
          </p>
          <p>
            We implemented the PIC/FLIP method described by Matthias Müller from
            Ten Minute Physics. In the walkthrough, a choice was raised when
            transferring velocities from the grid to the particles. A simple
            bilinear interpolation will get us a PIC value, which is smoother
            but loses detail. Alternatively, we can compute a bilinear
            interpolation on the change in velocity, which maintains more
            information about the individual particle movements but could have
            too much detail. For our purposes, we preferred a smoother fluid
            motion, which we felt was a better fit for our cartoonish art style,
            so we only implemented PIC velocity transfer.
          </p>
          <p>
            Aside from the algorithms mentioned above, the PIC/FLIP method as
            introduced by Matthias Müller also involves a drift solver, which
            ensures that particles do not collide with each other. This involves
            both accounting for drift in the incompressibility solver to
            generate more outward force in dense areas, as well as a self
            collision check.
          </p>
          <p>
            A naive approach for self collision would involve a double for-loop
            across all particles, twice. This would be far too slow for large
            quantities of particles. To speed things up, we implemented a
            spatial hashing algorithm also described by Matthias Müller. The
            basic idea for this approach is to store a linked list of particles
            contained within each cell, which would allow us to iterate over
            only the particles contained in neighboring cells.
          </p>
          <p>
            Under the hood, we keep track of three dense arrays to avoid the
            memory overhead of linked lists, which you can find the
            implementation details of in the spatial hashing presentation by
            Matthias Müller. With this partitioning, if we engineer the cell
            size in this grid to be at least as large as the diameter of each
            particle, we can ensure that we only have to check the particles
            contained in neighboring 3x3 cells for particle collisions. With
            this, we can reduce the runtime from O(n^2) down to a swift O(n).
          </p>
        </section>
        <section>
          <h3>Game Details</h3>
          <p>
            To achieve high definition fluid-terrain collisions, we implemented
            signed distance fields for each level. A signed distance field
            stores the distance to the nearest obstacle (or terrain) for each
            pixel, its value being negative if it is within an object. This
            distance field will be precomputed as a texture for each level,
            which can be easily loaded and modified by the user during runtime.
            After each particle integration step, we check the value of the
            distance field at its position. If that value is negative, then we
            take a step back by that distance so the particle ends up on the
            surface of the terrain. [need further clarifications from Ben]
          </p>
          <p>
            We wanted multiple levels to showcase different interactions with
            fluid dynamics. We also wanted this level loading process to be
            simple to tinker around by anyone with access to a digital art
            program like Gimp. We decided the best way to approach this is to
            take in a layer for each cell type (e.g. terrain, water, stone,
            drain). We would then initialize the simulation by sampling the
            texture and setting the appropriate cell type based on the alpha of
            the layer. With this approach, we can use texture sampling in the
            display to render custom terrain art that maps even to the destroyed
            terrain.
          </p>
          <p>
            For our game, we wanted to know how much fluid entered the target
            area. We also want any fluid that enters the area to “disappear”
            completely, so it won't interfere with any subsequent fluid flow.
            This ended up simpler than imagined. We simply added a “drain cell”
            that would disable any fluid particles that entered the cell and
            increment a global counter for each particle. Once it reaches a
            certain threshold, we would declare the level beaten.
          </p>
        </section>
        <section>
          <h3>Challenges</h3>
          <p>
            Initially, we planned to take advantage of the simplicity of compute
            shaders in Unity to parallelize and speed up our simulation
            computations. Unfortunately, we only realized half way through
            implementation that the PIC/FLIP simulation would require a lot more
            effort to parallelize as the velocity transfer required an
            accumulation of velocities from nearby particles, which would
            trigger data races when parallelized. There are certainly
            workarounds, but we didn't think we would be able to achieve our MVP
            in time if we were to pursue them, so we caved in and switched to an
            all CPU approach. Fortunately, it is still reasonably fast.
          </p>
          <p>
            During development, we realized that the particles move extremely
            slowly at a target of 60fps. Thinking it was due to a slow
            computation, we simply switched to a larger time step to achieve a
            similar speed as the FLIP website demo. Unfortunately, having a
            larger delta time came at a cost, and we had to spend a long time
            debugging an unstable simulation later down the line. We eventually
            figured out that it was not an issue of slow computation, but rather
            incorrect coordinate systems. The particles had been mapped to a
            much larger space and simply projected down by the display code to
            appear normal sized. Once we mapped the coordinates to scale with
            the screen, everything moved smoothly along at a stable pace.
          </p>
        </section>
        <section>
          <h3>Lessons</h3>
          <p>
            Plan and design carefully before making a bold move, and don't make
            any assumptions about the model.
          </p>
          <p>
            Investigate further before settling down on a band-aid solution.
            Tech debt will always come back to bite you.
          </p>
        </section>
        <section>
          <h2>Results</h2>
          <figure>
            <img src="../assets/fluid_sim.gif" />
            <figcaption>The PIC/FLIP fluid simulation in a box.</figcaption>
          </figure>
        </section>
        <section>
          <h2>References</h2>
          <ul>
            <li>
              <a
                href="https://youtu.be/rSKMYc1CQHE?si=xTG0WXi_AWpkNybU"
                target="_blank"
                >Sebastian Lague: Simulating Fluids</a
              >
            </li>
            <li>
              <a
                href="https://youtu.be/kOkfC5fLfgE?si=Uow-iHo_9-hMWghk"
                target="_blank"
                >Sebastian Lague: Rendering Fluids with Ray Marching</a
              >
            </li>
            <li>
              <a
                href="https://youtu.be/XmzBREkK8kY?si=VxxH-1ZRQ0JZLGOp"
                target="_blank"
                >Ten Minute Physics: FLIP Fluid Simulation</a
              >
            </li>
            <li>
              <a
                href="https://youtu.be/iKAVRgIrUOU?si=PN46nOBc3nEy25PU"
                target="_blank"
                >Ten Minute Physics: Eulerian Fluid Simulation</a
              >
            </li>
            <li>
              <a
                href="https://www.youtube.com/watch?v=D2M8jTtKi44"
                target="_blank"
                >Ten Minute Physics: Spatial Hashing</a
              >
            </li>
          </ul>
        </section>
        <section>
          <h2>Contributions</h2>
          <p>
            <strong>Ann Basil:</strong> Level design, art assets, menu UI, level
            selection.
          </p>
          <p>
            <strong>Ben Bliss:</strong> Distance field generation,
            particle-terrain collisions, terrain destruction.
          </p>
          <p>
            <strong>David Hernandez:</strong> Level loading and scoring system.
          </p>
          <p>
            <strong>Jinkang Fang:</strong> Fluid simulation and spatial hashing.
          </p>
        </section>
      </article>
    </main>

    <footer>
      <div>
        <img src="../assets/184_david.png" alt="Fishy David" width="200" />
        <p>Fishy David</p>
      </div>
      <div>
        <img src="../assets/184_ann.png" alt="Fishy Ann" width="200" />
        <p>Fishy Ann</p>
      </div>
      <div>
        <img src="../assets/184_ben.png" alt="Fishy Ben" width="200" />
        <p>Fishy Ben</p>
      </div>
      <div>
        <img src="../assets/184_jinkang.png" alt="Fishy Jinkang" width="200" />
        <p>Fishy Jinkang</p>
      </div>
    </footer>
  </body>
</html>
