#pragma kernel ExternalForces
#pragma kernel UserInput
#pragma kernel Projection

static const int NumThreads = 64;

// buffers
//
// Staggered velocity grid:
// - vertical velocity tracks velocity above cell
// - horizontal velocity tracks velocity left of cell
//
// Side effect:
//     bottom row won't have velocity below it, rightmost col won't have velocity right of it
//     but that doesn't matter - just have to check for bounds and adjust accordingly
//
RWStructuredBuffer<int> cellTypes;
RWStructuredBuffer<float2> cellVelocitiesIn;
RWStructuredBuffer<float2> cellVelocitiesOut;
RWStructuredBuffer<float2> particleVelocitiesIn;
RWStructuredBuffer<float2> particleVelocitiesOut;
RWStructuredBuffer<float2> positionsIn;
RWStructuredBuffer<float2> positionsOut;

// settings
float gravity;
float deltaTime;
float2 boundsSize;
float2 cellSize;
int2 size;
uint totalCells;
uint numParticles;

float2 interactionInputPoint;
int interactionInputType;
float interactionInputRadius;
float interactionInputStrength;

// constants
const float overRelaxation = 1.9;

static const uint FIELD_HORIZONTAL_VELOCITY = 0;
static const uint FIELD_VERTICAL_VELOCITY = 1;
static const uint FIELD_DENSITY = 2;

//
// helpers to work with coordinates
//
uint idToCol(uint id)
{
    return id % size.x;
}

uint idToRow(uint id)
{
    return id / size.x;
}

// uint idx(uint x, uint y)
// {
//     return y * size.x + x;
// }

float2 gridPosition(const uint col, const uint row)
{
    const float2 boundCorner = -boundsSize / 2;
    return boundCorner + (float2(col, row) + 0.5) * cellSize;
}

float2 clampPosition(const float2 p)
{
    const float2 lowerLeft = float2(0, 0);
    const float2 upperRight = size;
    return max(min(p, upperRight), lowerLeft);
}

//
// fluid sim functions
//

//
// kernels
//

[numthreads(NumThreads, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalCells) return;

    // copy values to ensure no data loss
    cellVelocitiesOut[id.x] = cellVelocitiesIn[id.x];
    
    // exit if cell is on border
    const int row = idToRow(id.x);
    if (row == 0) return;
    
    // apply gravity to velocity between empty cells
    if (cellTypes[id.x] == 0 && cellTypes[id.x - size.x] == 0)
    {
        cellVelocitiesOut[id.x] = cellVelocitiesIn[id.x] + float2(0, gravity) * deltaTime;
    }
}

[numthreads(NumThreads, 1, 1)]
void UserInput(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalCells) return;

    // copy values to ensure no data loss
    cellVelocitiesOut[id.x] = cellVelocitiesIn[id.x];
    
    // exit if cell is on border
    const int row = idToRow(id.x);
    const int col = idToCol(id.x);
    if (row == 0 || col == 0 || row == size.y - 1 || col == size.x - 1) return;

    // ensure cell is within interaction radius
    const float2 pos = gridPosition(col, row);
    const float2 offset = interactionInputPoint - pos;
    const float sqrDst = dot(offset, offset);
    if (sqrDst > interactionInputRadius * interactionInputRadius) return;
    
    // clear destructible terrain
    if (cellTypes[id.x] == 1 && interactionInputType == 2)
    {
        cellTypes[id.x] = 0;
    }
    // influence velocity field
    else if (cellTypes[id.x] == 0 && interactionInputType == 1)
    {
        // const float dist = sqrt(sqrDst);
        // const float pullStrength = (dist / interactionInputRadius) * interactionInputStrength;
        cellVelocitiesOut[id.x] = cellVelocitiesIn[id.x] + 0.1f;
    }
}

[numthreads(NumThreads, 1, 1)]
void Projection(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalCells) return;
    if (cellTypes[id.x] != 0) return;
    
    // copy values to ensure no data loss
    cellVelocitiesOut[id.x] = cellVelocitiesIn[id.x];

    // exit if it is on a bound
    const int col = idToCol(id.x);
    const int row = idToRow(id.x);
    if (row == 0 || row == size.y-1 || col == 0 || col == size.x-1) return;
    
    // check cell types
    const int sLeft = cellTypes[id.x-1] == 0 ? 1 : 0;
    const int sRight = cellTypes[id.x+1] == 0 ? 1 : 0;
    const int sUp = cellTypes[id.x - size.x] == 0 ? 1 : 0;
    const int sDown = cellTypes[id.x + size.x] == 0 ? 1 : 0;
    const int s = sLeft + sRight + sUp + sDown;
    if (s == 0) return;
    
    // compute divergence
    float d = cellVelocitiesIn[id.x+1].x - cellVelocitiesIn[id.x].x + cellVelocitiesIn[id.x].y - cellVelocitiesIn[id.x + size.x].y;
    d *= overRelaxation / s;

    // solve incompressibility
    cellVelocitiesOut[id.x].x = cellVelocitiesIn[id.x].x + d * sLeft;
    cellVelocitiesOut[id.x+1].x = cellVelocitiesIn[id.x+1].x - d * sRight;
    cellVelocitiesOut[id.x].y = cellVelocitiesIn[id.x].y + d * sUp;
    cellVelocitiesOut[id.x+size.x].y = cellVelocitiesIn[id.x+size.x].y - d * sDown;
}
