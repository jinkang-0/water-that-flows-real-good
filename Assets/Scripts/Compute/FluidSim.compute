#pragma kernel ExternalForces
#pragma kernel UpdateCellTypes
#pragma kernel ApplyVelocities

static const int NumThreads = 64;

// buffers
RWStructuredBuffer<int> cellTypes;
RWStructuredBuffer<float> vrVelocities;
RWStructuredBuffer<float> vrVelocitiesOut;
RWStructuredBuffer<float> hrVelocities;
RWStructuredBuffer<float> hrVelocitiesOut;

// settings
const float gravity;
const float deltaTime;
const float2 boundsSize;
const float2 cellSize;
const int numRows;
const int numCols;
const uint totalCells;

const float2 interactionInputPoint;
const int interactionInputType;
const float interactionInputRadius;

int idToCol(uint id)
{
    return id % numCols;
}

int idToRow(uint id)
{
    return id / numCols;
}

float2 gridPosition(uint id)
{
    const int col = idToCol(id);
    const int row = idToRow(id);
    const float2 boundCorner = -boundsSize / 2;
    return boundCorner + (float2(col, row) + 0.5) * cellSize;
}

[numthreads(NumThreads, 1, 1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalCells) return;

    vrVelocitiesOut[id.x] = vrVelocities[id.x] + gravity * deltaTime;
}

[numthreads(NumThreads, 1, 1)]
void UpdateCellTypes(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalCells) return;

    if (cellTypes[id.x] == 1 && interactionInputType == 2)
    {
        // check if grid is within interaction radius
        const float2 pos = gridPosition(id.x);
        const float2 offset = interactionInputPoint - pos;
        const float sqrDist = dot(offset, offset);
        if (sqrDist < interactionInputRadius * interactionInputRadius)
        {
            cellTypes[id.x] = 0;
        }
    }
}

[numthreads(NumThreads, 1, 1)]
void ApplyVelocities(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= totalCells) return;

    vrVelocities[id.x] = vrVelocitiesOut[id.x];
    hrVelocities[id.x] = hrVelocitiesOut[id.x];
}
